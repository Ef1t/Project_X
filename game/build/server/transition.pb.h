// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transition.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transition_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transition_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transition_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transition_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transition_2eproto;
namespace trans {
class NewBulletMessage;
class NewBulletMessageDefaultTypeInternal;
extern NewBulletMessageDefaultTypeInternal _NewBulletMessage_default_instance_;
class NewPlayerMessage;
class NewPlayerMessageDefaultTypeInternal;
extern NewPlayerMessageDefaultTypeInternal _NewPlayerMessage_default_instance_;
class ServerToUserMessage;
class ServerToUserMessageDefaultTypeInternal;
extern ServerToUserMessageDefaultTypeInternal _ServerToUserMessage_default_instance_;
class ServerToUserVectorMessage;
class ServerToUserVectorMessageDefaultTypeInternal;
extern ServerToUserVectorMessageDefaultTypeInternal _ServerToUserVectorMessage_default_instance_;
class SessionCreatedMessage;
class SessionCreatedMessageDefaultTypeInternal;
extern SessionCreatedMessageDefaultTypeInternal _SessionCreatedMessage_default_instance_;
class UpdateBulletMessage;
class UpdateBulletMessageDefaultTypeInternal;
extern UpdateBulletMessageDefaultTypeInternal _UpdateBulletMessage_default_instance_;
class UpdateBulletMessage_Direction;
class UpdateBulletMessage_DirectionDefaultTypeInternal;
extern UpdateBulletMessage_DirectionDefaultTypeInternal _UpdateBulletMessage_Direction_default_instance_;
class UpdatePlayerMessage;
class UpdatePlayerMessageDefaultTypeInternal;
extern UpdatePlayerMessageDefaultTypeInternal _UpdatePlayerMessage_default_instance_;
class UpdatePlayerMessage_Direction;
class UpdatePlayerMessage_DirectionDefaultTypeInternal;
extern UpdatePlayerMessage_DirectionDefaultTypeInternal _UpdatePlayerMessage_Direction_default_instance_;
class UserInitMessage;
class UserInitMessageDefaultTypeInternal;
extern UserInitMessageDefaultTypeInternal _UserInitMessage_default_instance_;
class UserToServerMessage;
class UserToServerMessageDefaultTypeInternal;
extern UserToServerMessageDefaultTypeInternal _UserToServerMessage_default_instance_;
class UserToServerMessage_Direction;
class UserToServerMessage_DirectionDefaultTypeInternal;
extern UserToServerMessage_DirectionDefaultTypeInternal _UserToServerMessage_Direction_default_instance_;
}  // namespace trans
PROTOBUF_NAMESPACE_OPEN
template<> ::trans::NewBulletMessage* Arena::CreateMaybeMessage<::trans::NewBulletMessage>(Arena*);
template<> ::trans::NewPlayerMessage* Arena::CreateMaybeMessage<::trans::NewPlayerMessage>(Arena*);
template<> ::trans::ServerToUserMessage* Arena::CreateMaybeMessage<::trans::ServerToUserMessage>(Arena*);
template<> ::trans::ServerToUserVectorMessage* Arena::CreateMaybeMessage<::trans::ServerToUserVectorMessage>(Arena*);
template<> ::trans::SessionCreatedMessage* Arena::CreateMaybeMessage<::trans::SessionCreatedMessage>(Arena*);
template<> ::trans::UpdateBulletMessage* Arena::CreateMaybeMessage<::trans::UpdateBulletMessage>(Arena*);
template<> ::trans::UpdateBulletMessage_Direction* Arena::CreateMaybeMessage<::trans::UpdateBulletMessage_Direction>(Arena*);
template<> ::trans::UpdatePlayerMessage* Arena::CreateMaybeMessage<::trans::UpdatePlayerMessage>(Arena*);
template<> ::trans::UpdatePlayerMessage_Direction* Arena::CreateMaybeMessage<::trans::UpdatePlayerMessage_Direction>(Arena*);
template<> ::trans::UserInitMessage* Arena::CreateMaybeMessage<::trans::UserInitMessage>(Arena*);
template<> ::trans::UserToServerMessage* Arena::CreateMaybeMessage<::trans::UserToServerMessage>(Arena*);
template<> ::trans::UserToServerMessage_Direction* Arena::CreateMaybeMessage<::trans::UserToServerMessage_Direction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trans {

enum UserToServerMessage_MessageType : int {
  UserToServerMessage_MessageType_Standby = 0,
  UserToServerMessage_MessageType_Move = 1,
  UserToServerMessage_MessageType_UserToServerMessage_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserToServerMessage_MessageType_UserToServerMessage_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserToServerMessage_MessageType_IsValid(int value);
constexpr UserToServerMessage_MessageType UserToServerMessage_MessageType_MessageType_MIN = UserToServerMessage_MessageType_Standby;
constexpr UserToServerMessage_MessageType UserToServerMessage_MessageType_MessageType_MAX = UserToServerMessage_MessageType_Move;
constexpr int UserToServerMessage_MessageType_MessageType_ARRAYSIZE = UserToServerMessage_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserToServerMessage_MessageType_descriptor();
template<typename T>
inline const std::string& UserToServerMessage_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserToServerMessage_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserToServerMessage_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserToServerMessage_MessageType_descriptor(), enum_t_value);
}
inline bool UserToServerMessage_MessageType_Parse(
    const std::string& name, UserToServerMessage_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserToServerMessage_MessageType>(
    UserToServerMessage_MessageType_descriptor(), name, value);
}
enum UserInitMessage_Action : int {
  UserInitMessage_Action_Create = 0,
  UserInitMessage_Action_Join = 1,
  UserInitMessage_Action_UserInitMessage_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserInitMessage_Action_UserInitMessage_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserInitMessage_Action_IsValid(int value);
constexpr UserInitMessage_Action UserInitMessage_Action_Action_MIN = UserInitMessage_Action_Create;
constexpr UserInitMessage_Action UserInitMessage_Action_Action_MAX = UserInitMessage_Action_Join;
constexpr int UserInitMessage_Action_Action_ARRAYSIZE = UserInitMessage_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserInitMessage_Action_descriptor();
template<typename T>
inline const std::string& UserInitMessage_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserInitMessage_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserInitMessage_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserInitMessage_Action_descriptor(), enum_t_value);
}
inline bool UserInitMessage_Action_Parse(
    const std::string& name, UserInitMessage_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserInitMessage_Action>(
    UserInitMessage_Action_descriptor(), name, value);
}
enum ServerToUserMessage_MessageType : int {
  ServerToUserMessage_MessageType_NewPlayer = 0,
  ServerToUserMessage_MessageType_UpdatePlayer = 1,
  ServerToUserMessage_MessageType_NewBullet = 2,
  ServerToUserMessage_MessageType_UpdateBullet = 3,
  ServerToUserMessage_MessageType_ServerToUserMessage_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServerToUserMessage_MessageType_ServerToUserMessage_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServerToUserMessage_MessageType_IsValid(int value);
constexpr ServerToUserMessage_MessageType ServerToUserMessage_MessageType_MessageType_MIN = ServerToUserMessage_MessageType_NewPlayer;
constexpr ServerToUserMessage_MessageType ServerToUserMessage_MessageType_MessageType_MAX = ServerToUserMessage_MessageType_UpdateBullet;
constexpr int ServerToUserMessage_MessageType_MessageType_ARRAYSIZE = ServerToUserMessage_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerToUserMessage_MessageType_descriptor();
template<typename T>
inline const std::string& ServerToUserMessage_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerToUserMessage_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerToUserMessage_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerToUserMessage_MessageType_descriptor(), enum_t_value);
}
inline bool ServerToUserMessage_MessageType_Parse(
    const std::string& name, ServerToUserMessage_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerToUserMessage_MessageType>(
    ServerToUserMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class UserToServerMessage_Direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UserToServerMessage.Direction) */ {
 public:
  UserToServerMessage_Direction();
  virtual ~UserToServerMessage_Direction();

  UserToServerMessage_Direction(const UserToServerMessage_Direction& from);
  UserToServerMessage_Direction(UserToServerMessage_Direction&& from) noexcept
    : UserToServerMessage_Direction() {
    *this = ::std::move(from);
  }

  inline UserToServerMessage_Direction& operator=(const UserToServerMessage_Direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserToServerMessage_Direction& operator=(UserToServerMessage_Direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserToServerMessage_Direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserToServerMessage_Direction* internal_default_instance() {
    return reinterpret_cast<const UserToServerMessage_Direction*>(
               &_UserToServerMessage_Direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserToServerMessage_Direction& a, UserToServerMessage_Direction& b) {
    a.Swap(&b);
  }
  inline void Swap(UserToServerMessage_Direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserToServerMessage_Direction* New() const final {
    return CreateMaybeMessage<UserToServerMessage_Direction>(nullptr);
  }

  UserToServerMessage_Direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserToServerMessage_Direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserToServerMessage_Direction& from);
  void MergeFrom(const UserToServerMessage_Direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserToServerMessage_Direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UserToServerMessage.Direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kDownFieldNumber = 4,
    kFireFieldNumber = 5,
  };
  // bool up = 1;
  void clear_up();
  bool up() const;
  void set_up(bool value);
  private:
  bool _internal_up() const;
  void _internal_set_up(bool value);
  public:

  // bool left = 2;
  void clear_left();
  bool left() const;
  void set_left(bool value);
  private:
  bool _internal_left() const;
  void _internal_set_left(bool value);
  public:

  // bool right = 3;
  void clear_right();
  bool right() const;
  void set_right(bool value);
  private:
  bool _internal_right() const;
  void _internal_set_right(bool value);
  public:

  // bool down = 4;
  void clear_down();
  bool down() const;
  void set_down(bool value);
  private:
  bool _internal_down() const;
  void _internal_set_down(bool value);
  public:

  // bool fire = 5;
  void clear_fire();
  bool fire() const;
  void set_fire(bool value);
  private:
  bool _internal_fire() const;
  void _internal_set_fire(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UserToServerMessage.Direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool up_;
  bool left_;
  bool right_;
  bool down_;
  bool fire_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UserToServerMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UserToServerMessage) */ {
 public:
  UserToServerMessage();
  virtual ~UserToServerMessage();

  UserToServerMessage(const UserToServerMessage& from);
  UserToServerMessage(UserToServerMessage&& from) noexcept
    : UserToServerMessage() {
    *this = ::std::move(from);
  }

  inline UserToServerMessage& operator=(const UserToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserToServerMessage& operator=(UserToServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserToServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserToServerMessage* internal_default_instance() {
    return reinterpret_cast<const UserToServerMessage*>(
               &_UserToServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserToServerMessage& a, UserToServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UserToServerMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserToServerMessage* New() const final {
    return CreateMaybeMessage<UserToServerMessage>(nullptr);
  }

  UserToServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserToServerMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserToServerMessage& from);
  void MergeFrom(const UserToServerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserToServerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UserToServerMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UserToServerMessage_Direction Direction;

  typedef UserToServerMessage_MessageType MessageType;
  static constexpr MessageType Standby =
    UserToServerMessage_MessageType_Standby;
  static constexpr MessageType Move =
    UserToServerMessage_MessageType_Move;
  static inline bool MessageType_IsValid(int value) {
    return UserToServerMessage_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    UserToServerMessage_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    UserToServerMessage_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    UserToServerMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return UserToServerMessage_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return UserToServerMessage_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(const std::string& name,
      MessageType* value) {
    return UserToServerMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .trans.UserToServerMessage.Direction direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::trans::UserToServerMessage_Direction& direction() const;
  ::trans::UserToServerMessage_Direction* release_direction();
  ::trans::UserToServerMessage_Direction* mutable_direction();
  void set_allocated_direction(::trans::UserToServerMessage_Direction* direction);
  private:
  const ::trans::UserToServerMessage_Direction& _internal_direction() const;
  ::trans::UserToServerMessage_Direction* _internal_mutable_direction();
  public:

  // .trans.UserToServerMessage.MessageType type = 1;
  void clear_type();
  ::trans::UserToServerMessage_MessageType type() const;
  void set_type(::trans::UserToServerMessage_MessageType value);
  private:
  ::trans::UserToServerMessage_MessageType _internal_type() const;
  void _internal_set_type(::trans::UserToServerMessage_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UserToServerMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::trans::UserToServerMessage_Direction* direction_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class SessionCreatedMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.SessionCreatedMessage) */ {
 public:
  SessionCreatedMessage();
  virtual ~SessionCreatedMessage();

  SessionCreatedMessage(const SessionCreatedMessage& from);
  SessionCreatedMessage(SessionCreatedMessage&& from) noexcept
    : SessionCreatedMessage() {
    *this = ::std::move(from);
  }

  inline SessionCreatedMessage& operator=(const SessionCreatedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionCreatedMessage& operator=(SessionCreatedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionCreatedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionCreatedMessage* internal_default_instance() {
    return reinterpret_cast<const SessionCreatedMessage*>(
               &_SessionCreatedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionCreatedMessage& a, SessionCreatedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionCreatedMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionCreatedMessage* New() const final {
    return CreateMaybeMessage<SessionCreatedMessage>(nullptr);
  }

  SessionCreatedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionCreatedMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionCreatedMessage& from);
  void MergeFrom(const SessionCreatedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionCreatedMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.SessionCreatedMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // int32 session_id = 1;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::int32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:trans.SessionCreatedMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UserInitMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UserInitMessage) */ {
 public:
  UserInitMessage();
  virtual ~UserInitMessage();

  UserInitMessage(const UserInitMessage& from);
  UserInitMessage(UserInitMessage&& from) noexcept
    : UserInitMessage() {
    *this = ::std::move(from);
  }

  inline UserInitMessage& operator=(const UserInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInitMessage& operator=(UserInitMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserInitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInitMessage* internal_default_instance() {
    return reinterpret_cast<const UserInitMessage*>(
               &_UserInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserInitMessage& a, UserInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInitMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInitMessage* New() const final {
    return CreateMaybeMessage<UserInitMessage>(nullptr);
  }

  UserInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInitMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInitMessage& from);
  void MergeFrom(const UserInitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UserInitMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UserInitMessage_Action Action;
  static constexpr Action Create =
    UserInitMessage_Action_Create;
  static constexpr Action Join =
    UserInitMessage_Action_Join;
  static inline bool Action_IsValid(int value) {
    return UserInitMessage_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    UserInitMessage_Action_Action_MIN;
  static constexpr Action Action_MAX =
    UserInitMessage_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    UserInitMessage_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return UserInitMessage_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return UserInitMessage_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(const std::string& name,
      Action* value) {
    return UserInitMessage_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kMapNameFieldNumber = 4,
    kActionFieldNumber = 1,
    kSessionIdFieldNumber = 3,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string map_name = 4;
  void clear_map_name();
  const std::string& map_name() const;
  void set_map_name(const std::string& value);
  void set_map_name(std::string&& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  std::string* mutable_map_name();
  std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // .trans.UserInitMessage.Action action = 1;
  void clear_action();
  ::trans::UserInitMessage_Action action() const;
  void set_action(::trans::UserInitMessage_Action value);
  private:
  ::trans::UserInitMessage_Action _internal_action() const;
  void _internal_set_action(::trans::UserInitMessage_Action value);
  public:

  // int32 session_id = 3;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::int32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UserInitMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  int action_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class NewPlayerMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.NewPlayerMessage) */ {
 public:
  NewPlayerMessage();
  virtual ~NewPlayerMessage();

  NewPlayerMessage(const NewPlayerMessage& from);
  NewPlayerMessage(NewPlayerMessage&& from) noexcept
    : NewPlayerMessage() {
    *this = ::std::move(from);
  }

  inline NewPlayerMessage& operator=(const NewPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewPlayerMessage& operator=(NewPlayerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewPlayerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const NewPlayerMessage*>(
               &_NewPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewPlayerMessage& a, NewPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NewPlayerMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewPlayerMessage* New() const final {
    return CreateMaybeMessage<NewPlayerMessage>(nullptr);
  }

  NewPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewPlayerMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewPlayerMessage& from);
  void MergeFrom(const NewPlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewPlayerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.NewPlayerMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kMapNameFieldNumber = 5,
    kIdFieldNumber = 1,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string map_name = 5;
  void clear_map_name();
  const std::string& map_name() const;
  void set_map_name(const std::string& value);
  void set_map_name(std::string&& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  std::string* mutable_map_name();
  std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:trans.NewPlayerMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerMessage_Direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UpdatePlayerMessage.Direction) */ {
 public:
  UpdatePlayerMessage_Direction();
  virtual ~UpdatePlayerMessage_Direction();

  UpdatePlayerMessage_Direction(const UpdatePlayerMessage_Direction& from);
  UpdatePlayerMessage_Direction(UpdatePlayerMessage_Direction&& from) noexcept
    : UpdatePlayerMessage_Direction() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerMessage_Direction& operator=(const UpdatePlayerMessage_Direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerMessage_Direction& operator=(UpdatePlayerMessage_Direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePlayerMessage_Direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePlayerMessage_Direction* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerMessage_Direction*>(
               &_UpdatePlayerMessage_Direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdatePlayerMessage_Direction& a, UpdatePlayerMessage_Direction& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerMessage_Direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerMessage_Direction* New() const final {
    return CreateMaybeMessage<UpdatePlayerMessage_Direction>(nullptr);
  }

  UpdatePlayerMessage_Direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayerMessage_Direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePlayerMessage_Direction& from);
  void MergeFrom(const UpdatePlayerMessage_Direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerMessage_Direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UpdatePlayerMessage.Direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kDownFieldNumber = 4,
    kFireFieldNumber = 5,
  };
  // bool up = 1;
  void clear_up();
  bool up() const;
  void set_up(bool value);
  private:
  bool _internal_up() const;
  void _internal_set_up(bool value);
  public:

  // bool left = 2;
  void clear_left();
  bool left() const;
  void set_left(bool value);
  private:
  bool _internal_left() const;
  void _internal_set_left(bool value);
  public:

  // bool right = 3;
  void clear_right();
  bool right() const;
  void set_right(bool value);
  private:
  bool _internal_right() const;
  void _internal_set_right(bool value);
  public:

  // bool down = 4;
  void clear_down();
  bool down() const;
  void set_down(bool value);
  private:
  bool _internal_down() const;
  void _internal_set_down(bool value);
  public:

  // bool fire = 5;
  void clear_fire();
  bool fire() const;
  void set_fire(bool value);
  private:
  bool _internal_fire() const;
  void _internal_set_fire(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UpdatePlayerMessage.Direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool up_;
  bool left_;
  bool right_;
  bool down_;
  bool fire_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UpdatePlayerMessage) */ {
 public:
  UpdatePlayerMessage();
  virtual ~UpdatePlayerMessage();

  UpdatePlayerMessage(const UpdatePlayerMessage& from);
  UpdatePlayerMessage(UpdatePlayerMessage&& from) noexcept
    : UpdatePlayerMessage() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerMessage& operator=(const UpdatePlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerMessage& operator=(UpdatePlayerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePlayerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePlayerMessage* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerMessage*>(
               &_UpdatePlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdatePlayerMessage& a, UpdatePlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerMessage* New() const final {
    return CreateMaybeMessage<UpdatePlayerMessage>(nullptr);
  }

  UpdatePlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayerMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePlayerMessage& from);
  void MergeFrom(const UpdatePlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UpdatePlayerMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UpdatePlayerMessage_Direction Direction;

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 4,
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // .trans.UpdatePlayerMessage.Direction direction = 4;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::trans::UpdatePlayerMessage_Direction& direction() const;
  ::trans::UpdatePlayerMessage_Direction* release_direction();
  ::trans::UpdatePlayerMessage_Direction* mutable_direction();
  void set_allocated_direction(::trans::UpdatePlayerMessage_Direction* direction);
  private:
  const ::trans::UpdatePlayerMessage_Direction& _internal_direction() const;
  ::trans::UpdatePlayerMessage_Direction* _internal_mutable_direction();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UpdatePlayerMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::trans::UpdatePlayerMessage_Direction* direction_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class NewBulletMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.NewBulletMessage) */ {
 public:
  NewBulletMessage();
  virtual ~NewBulletMessage();

  NewBulletMessage(const NewBulletMessage& from);
  NewBulletMessage(NewBulletMessage&& from) noexcept
    : NewBulletMessage() {
    *this = ::std::move(from);
  }

  inline NewBulletMessage& operator=(const NewBulletMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewBulletMessage& operator=(NewBulletMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewBulletMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewBulletMessage* internal_default_instance() {
    return reinterpret_cast<const NewBulletMessage*>(
               &_NewBulletMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewBulletMessage& a, NewBulletMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NewBulletMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewBulletMessage* New() const final {
    return CreateMaybeMessage<NewBulletMessage>(nullptr);
  }

  NewBulletMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewBulletMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewBulletMessage& from);
  void MergeFrom(const NewBulletMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewBulletMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.NewBulletMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 4,
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // string map_name = 4;
  void clear_map_name();
  const std::string& map_name() const;
  void set_map_name(const std::string& value);
  void set_map_name(std::string&& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  std::string* mutable_map_name();
  std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:trans.NewBulletMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UpdateBulletMessage_Direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UpdateBulletMessage.Direction) */ {
 public:
  UpdateBulletMessage_Direction();
  virtual ~UpdateBulletMessage_Direction();

  UpdateBulletMessage_Direction(const UpdateBulletMessage_Direction& from);
  UpdateBulletMessage_Direction(UpdateBulletMessage_Direction&& from) noexcept
    : UpdateBulletMessage_Direction() {
    *this = ::std::move(from);
  }

  inline UpdateBulletMessage_Direction& operator=(const UpdateBulletMessage_Direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBulletMessage_Direction& operator=(UpdateBulletMessage_Direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateBulletMessage_Direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateBulletMessage_Direction* internal_default_instance() {
    return reinterpret_cast<const UpdateBulletMessage_Direction*>(
               &_UpdateBulletMessage_Direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateBulletMessage_Direction& a, UpdateBulletMessage_Direction& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBulletMessage_Direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateBulletMessage_Direction* New() const final {
    return CreateMaybeMessage<UpdateBulletMessage_Direction>(nullptr);
  }

  UpdateBulletMessage_Direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateBulletMessage_Direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateBulletMessage_Direction& from);
  void MergeFrom(const UpdateBulletMessage_Direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBulletMessage_Direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UpdateBulletMessage.Direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kDownFieldNumber = 4,
  };
  // bool up = 1;
  void clear_up();
  bool up() const;
  void set_up(bool value);
  private:
  bool _internal_up() const;
  void _internal_set_up(bool value);
  public:

  // bool left = 2;
  void clear_left();
  bool left() const;
  void set_left(bool value);
  private:
  bool _internal_left() const;
  void _internal_set_left(bool value);
  public:

  // bool right = 3;
  void clear_right();
  bool right() const;
  void set_right(bool value);
  private:
  bool _internal_right() const;
  void _internal_set_right(bool value);
  public:

  // bool down = 4;
  void clear_down();
  bool down() const;
  void set_down(bool value);
  private:
  bool _internal_down() const;
  void _internal_set_down(bool value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UpdateBulletMessage.Direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool up_;
  bool left_;
  bool right_;
  bool down_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class UpdateBulletMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.UpdateBulletMessage) */ {
 public:
  UpdateBulletMessage();
  virtual ~UpdateBulletMessage();

  UpdateBulletMessage(const UpdateBulletMessage& from);
  UpdateBulletMessage(UpdateBulletMessage&& from) noexcept
    : UpdateBulletMessage() {
    *this = ::std::move(from);
  }

  inline UpdateBulletMessage& operator=(const UpdateBulletMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBulletMessage& operator=(UpdateBulletMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateBulletMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateBulletMessage* internal_default_instance() {
    return reinterpret_cast<const UpdateBulletMessage*>(
               &_UpdateBulletMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateBulletMessage& a, UpdateBulletMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBulletMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateBulletMessage* New() const final {
    return CreateMaybeMessage<UpdateBulletMessage>(nullptr);
  }

  UpdateBulletMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateBulletMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateBulletMessage& from);
  void MergeFrom(const UpdateBulletMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBulletMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.UpdateBulletMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UpdateBulletMessage_Direction Direction;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:trans.UpdateBulletMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class ServerToUserMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.ServerToUserMessage) */ {
 public:
  ServerToUserMessage();
  virtual ~ServerToUserMessage();

  ServerToUserMessage(const ServerToUserMessage& from);
  ServerToUserMessage(ServerToUserMessage&& from) noexcept
    : ServerToUserMessage() {
    *this = ::std::move(from);
  }

  inline ServerToUserMessage& operator=(const ServerToUserMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToUserMessage& operator=(ServerToUserMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToUserMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToUserMessage* internal_default_instance() {
    return reinterpret_cast<const ServerToUserMessage*>(
               &_ServerToUserMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ServerToUserMessage& a, ServerToUserMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToUserMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToUserMessage* New() const final {
    return CreateMaybeMessage<ServerToUserMessage>(nullptr);
  }

  ServerToUserMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToUserMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToUserMessage& from);
  void MergeFrom(const ServerToUserMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToUserMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.ServerToUserMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ServerToUserMessage_MessageType MessageType;
  static constexpr MessageType NewPlayer =
    ServerToUserMessage_MessageType_NewPlayer;
  static constexpr MessageType UpdatePlayer =
    ServerToUserMessage_MessageType_UpdatePlayer;
  static constexpr MessageType NewBullet =
    ServerToUserMessage_MessageType_NewBullet;
  static constexpr MessageType UpdateBullet =
    ServerToUserMessage_MessageType_UpdateBullet;
  static inline bool MessageType_IsValid(int value) {
    return ServerToUserMessage_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    ServerToUserMessage_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    ServerToUserMessage_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    ServerToUserMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return ServerToUserMessage_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return ServerToUserMessage_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(const std::string& name,
      MessageType* value) {
    return ServerToUserMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNpMsgFieldNumber = 2,
    kUpdMsgFieldNumber = 3,
    kNbMsgFieldNumber = 4,
    kUbMsgFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .trans.NewPlayerMessage np_msg = 2;
  bool has_np_msg() const;
  private:
  bool _internal_has_np_msg() const;
  public:
  void clear_np_msg();
  const ::trans::NewPlayerMessage& np_msg() const;
  ::trans::NewPlayerMessage* release_np_msg();
  ::trans::NewPlayerMessage* mutable_np_msg();
  void set_allocated_np_msg(::trans::NewPlayerMessage* np_msg);
  private:
  const ::trans::NewPlayerMessage& _internal_np_msg() const;
  ::trans::NewPlayerMessage* _internal_mutable_np_msg();
  public:

  // .trans.UpdatePlayerMessage upd_msg = 3;
  bool has_upd_msg() const;
  private:
  bool _internal_has_upd_msg() const;
  public:
  void clear_upd_msg();
  const ::trans::UpdatePlayerMessage& upd_msg() const;
  ::trans::UpdatePlayerMessage* release_upd_msg();
  ::trans::UpdatePlayerMessage* mutable_upd_msg();
  void set_allocated_upd_msg(::trans::UpdatePlayerMessage* upd_msg);
  private:
  const ::trans::UpdatePlayerMessage& _internal_upd_msg() const;
  ::trans::UpdatePlayerMessage* _internal_mutable_upd_msg();
  public:

  // .trans.NewBulletMessage nb_msg = 4;
  bool has_nb_msg() const;
  private:
  bool _internal_has_nb_msg() const;
  public:
  void clear_nb_msg();
  const ::trans::NewBulletMessage& nb_msg() const;
  ::trans::NewBulletMessage* release_nb_msg();
  ::trans::NewBulletMessage* mutable_nb_msg();
  void set_allocated_nb_msg(::trans::NewBulletMessage* nb_msg);
  private:
  const ::trans::NewBulletMessage& _internal_nb_msg() const;
  ::trans::NewBulletMessage* _internal_mutable_nb_msg();
  public:

  // .trans.UpdateBulletMessage ub_msg = 5;
  bool has_ub_msg() const;
  private:
  bool _internal_has_ub_msg() const;
  public:
  void clear_ub_msg();
  const ::trans::UpdateBulletMessage& ub_msg() const;
  ::trans::UpdateBulletMessage* release_ub_msg();
  ::trans::UpdateBulletMessage* mutable_ub_msg();
  void set_allocated_ub_msg(::trans::UpdateBulletMessage* ub_msg);
  private:
  const ::trans::UpdateBulletMessage& _internal_ub_msg() const;
  ::trans::UpdateBulletMessage* _internal_mutable_ub_msg();
  public:

  // .trans.ServerToUserMessage.MessageType type = 1;
  void clear_type();
  ::trans::ServerToUserMessage_MessageType type() const;
  void set_type(::trans::ServerToUserMessage_MessageType value);
  private:
  ::trans::ServerToUserMessage_MessageType _internal_type() const;
  void _internal_set_type(::trans::ServerToUserMessage_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:trans.ServerToUserMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::trans::NewPlayerMessage* np_msg_;
  ::trans::UpdatePlayerMessage* upd_msg_;
  ::trans::NewBulletMessage* nb_msg_;
  ::trans::UpdateBulletMessage* ub_msg_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// -------------------------------------------------------------------

class ServerToUserVectorMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trans.ServerToUserVectorMessage) */ {
 public:
  ServerToUserVectorMessage();
  virtual ~ServerToUserVectorMessage();

  ServerToUserVectorMessage(const ServerToUserVectorMessage& from);
  ServerToUserVectorMessage(ServerToUserVectorMessage&& from) noexcept
    : ServerToUserVectorMessage() {
    *this = ::std::move(from);
  }

  inline ServerToUserVectorMessage& operator=(const ServerToUserVectorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToUserVectorMessage& operator=(ServerToUserVectorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToUserVectorMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToUserVectorMessage* internal_default_instance() {
    return reinterpret_cast<const ServerToUserVectorMessage*>(
               &_ServerToUserVectorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ServerToUserVectorMessage& a, ServerToUserVectorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToUserVectorMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToUserVectorMessage* New() const final {
    return CreateMaybeMessage<ServerToUserVectorMessage>(nullptr);
  }

  ServerToUserVectorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToUserVectorMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToUserVectorMessage& from);
  void MergeFrom(const ServerToUserVectorMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToUserVectorMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trans.ServerToUserVectorMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transition_2eproto);
    return ::descriptor_table_transition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecMessagesFieldNumber = 1,
  };
  // repeated .trans.ServerToUserMessage vec_messages = 1;
  int vec_messages_size() const;
  private:
  int _internal_vec_messages_size() const;
  public:
  void clear_vec_messages();
  ::trans::ServerToUserMessage* mutable_vec_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trans::ServerToUserMessage >*
      mutable_vec_messages();
  private:
  const ::trans::ServerToUserMessage& _internal_vec_messages(int index) const;
  ::trans::ServerToUserMessage* _internal_add_vec_messages();
  public:
  const ::trans::ServerToUserMessage& vec_messages(int index) const;
  ::trans::ServerToUserMessage* add_vec_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trans::ServerToUserMessage >&
      vec_messages() const;

  // @@protoc_insertion_point(class_scope:trans.ServerToUserVectorMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trans::ServerToUserMessage > vec_messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transition_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserToServerMessage_Direction

// bool up = 1;
inline void UserToServerMessage_Direction::clear_up() {
  up_ = false;
}
inline bool UserToServerMessage_Direction::_internal_up() const {
  return up_;
}
inline bool UserToServerMessage_Direction::up() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.Direction.up)
  return _internal_up();
}
inline void UserToServerMessage_Direction::_internal_set_up(bool value) {
  
  up_ = value;
}
inline void UserToServerMessage_Direction::set_up(bool value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.Direction.up)
}

// bool left = 2;
inline void UserToServerMessage_Direction::clear_left() {
  left_ = false;
}
inline bool UserToServerMessage_Direction::_internal_left() const {
  return left_;
}
inline bool UserToServerMessage_Direction::left() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.Direction.left)
  return _internal_left();
}
inline void UserToServerMessage_Direction::_internal_set_left(bool value) {
  
  left_ = value;
}
inline void UserToServerMessage_Direction::set_left(bool value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.Direction.left)
}

// bool right = 3;
inline void UserToServerMessage_Direction::clear_right() {
  right_ = false;
}
inline bool UserToServerMessage_Direction::_internal_right() const {
  return right_;
}
inline bool UserToServerMessage_Direction::right() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.Direction.right)
  return _internal_right();
}
inline void UserToServerMessage_Direction::_internal_set_right(bool value) {
  
  right_ = value;
}
inline void UserToServerMessage_Direction::set_right(bool value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.Direction.right)
}

// bool down = 4;
inline void UserToServerMessage_Direction::clear_down() {
  down_ = false;
}
inline bool UserToServerMessage_Direction::_internal_down() const {
  return down_;
}
inline bool UserToServerMessage_Direction::down() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.Direction.down)
  return _internal_down();
}
inline void UserToServerMessage_Direction::_internal_set_down(bool value) {
  
  down_ = value;
}
inline void UserToServerMessage_Direction::set_down(bool value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.Direction.down)
}

// bool fire = 5;
inline void UserToServerMessage_Direction::clear_fire() {
  fire_ = false;
}
inline bool UserToServerMessage_Direction::_internal_fire() const {
  return fire_;
}
inline bool UserToServerMessage_Direction::fire() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.Direction.fire)
  return _internal_fire();
}
inline void UserToServerMessage_Direction::_internal_set_fire(bool value) {
  
  fire_ = value;
}
inline void UserToServerMessage_Direction::set_fire(bool value) {
  _internal_set_fire(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.Direction.fire)
}

// -------------------------------------------------------------------

// UserToServerMessage

// .trans.UserToServerMessage.MessageType type = 1;
inline void UserToServerMessage::clear_type() {
  type_ = 0;
}
inline ::trans::UserToServerMessage_MessageType UserToServerMessage::_internal_type() const {
  return static_cast< ::trans::UserToServerMessage_MessageType >(type_);
}
inline ::trans::UserToServerMessage_MessageType UserToServerMessage::type() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.type)
  return _internal_type();
}
inline void UserToServerMessage::_internal_set_type(::trans::UserToServerMessage_MessageType value) {
  
  type_ = value;
}
inline void UserToServerMessage::set_type(::trans::UserToServerMessage_MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:trans.UserToServerMessage.type)
}

// .trans.UserToServerMessage.Direction direction = 2;
inline bool UserToServerMessage::_internal_has_direction() const {
  return this != internal_default_instance() && direction_ != nullptr;
}
inline bool UserToServerMessage::has_direction() const {
  return _internal_has_direction();
}
inline void UserToServerMessage::clear_direction() {
  if (GetArenaNoVirtual() == nullptr && direction_ != nullptr) {
    delete direction_;
  }
  direction_ = nullptr;
}
inline const ::trans::UserToServerMessage_Direction& UserToServerMessage::_internal_direction() const {
  const ::trans::UserToServerMessage_Direction* p = direction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::UserToServerMessage_Direction*>(
      &::trans::_UserToServerMessage_Direction_default_instance_);
}
inline const ::trans::UserToServerMessage_Direction& UserToServerMessage::direction() const {
  // @@protoc_insertion_point(field_get:trans.UserToServerMessage.direction)
  return _internal_direction();
}
inline ::trans::UserToServerMessage_Direction* UserToServerMessage::release_direction() {
  // @@protoc_insertion_point(field_release:trans.UserToServerMessage.direction)
  
  ::trans::UserToServerMessage_Direction* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::trans::UserToServerMessage_Direction* UserToServerMessage::_internal_mutable_direction() {
  
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::UserToServerMessage_Direction>(GetArenaNoVirtual());
    direction_ = p;
  }
  return direction_;
}
inline ::trans::UserToServerMessage_Direction* UserToServerMessage::mutable_direction() {
  // @@protoc_insertion_point(field_mutable:trans.UserToServerMessage.direction)
  return _internal_mutable_direction();
}
inline void UserToServerMessage::set_allocated_direction(::trans::UserToServerMessage_Direction* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:trans.UserToServerMessage.direction)
}

// -------------------------------------------------------------------

// SessionCreatedMessage

// int32 session_id = 1;
inline void SessionCreatedMessage::clear_session_id() {
  session_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCreatedMessage::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SessionCreatedMessage::session_id() const {
  // @@protoc_insertion_point(field_get:trans.SessionCreatedMessage.session_id)
  return _internal_session_id();
}
inline void SessionCreatedMessage::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  session_id_ = value;
}
inline void SessionCreatedMessage::set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:trans.SessionCreatedMessage.session_id)
}

// -------------------------------------------------------------------

// UserInitMessage

// .trans.UserInitMessage.Action action = 1;
inline void UserInitMessage::clear_action() {
  action_ = 0;
}
inline ::trans::UserInitMessage_Action UserInitMessage::_internal_action() const {
  return static_cast< ::trans::UserInitMessage_Action >(action_);
}
inline ::trans::UserInitMessage_Action UserInitMessage::action() const {
  // @@protoc_insertion_point(field_get:trans.UserInitMessage.action)
  return _internal_action();
}
inline void UserInitMessage::_internal_set_action(::trans::UserInitMessage_Action value) {
  
  action_ = value;
}
inline void UserInitMessage::set_action(::trans::UserInitMessage_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:trans.UserInitMessage.action)
}

// string username = 2;
inline void UserInitMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UserInitMessage::username() const {
  // @@protoc_insertion_point(field_get:trans.UserInitMessage.username)
  return _internal_username();
}
inline void UserInitMessage::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:trans.UserInitMessage.username)
}
inline std::string* UserInitMessage::mutable_username() {
  // @@protoc_insertion_point(field_mutable:trans.UserInitMessage.username)
  return _internal_mutable_username();
}
inline const std::string& UserInitMessage::_internal_username() const {
  return username_.GetNoArena();
}
inline void UserInitMessage::_internal_set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UserInitMessage::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trans.UserInitMessage.username)
}
inline void UserInitMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trans.UserInitMessage.username)
}
inline void UserInitMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trans.UserInitMessage.username)
}
inline std::string* UserInitMessage::_internal_mutable_username() {
  
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserInitMessage::release_username() {
  // @@protoc_insertion_point(field_release:trans.UserInitMessage.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserInitMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:trans.UserInitMessage.username)
}

// int32 session_id = 3;
inline void UserInitMessage::clear_session_id() {
  session_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserInitMessage::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserInitMessage::session_id() const {
  // @@protoc_insertion_point(field_get:trans.UserInitMessage.session_id)
  return _internal_session_id();
}
inline void UserInitMessage::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  session_id_ = value;
}
inline void UserInitMessage::set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:trans.UserInitMessage.session_id)
}

// string map_name = 4;
inline void UserInitMessage::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UserInitMessage::map_name() const {
  // @@protoc_insertion_point(field_get:trans.UserInitMessage.map_name)
  return _internal_map_name();
}
inline void UserInitMessage::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:trans.UserInitMessage.map_name)
}
inline std::string* UserInitMessage::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:trans.UserInitMessage.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& UserInitMessage::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void UserInitMessage::_internal_set_map_name(const std::string& value) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UserInitMessage::set_map_name(std::string&& value) {
  
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trans.UserInitMessage.map_name)
}
inline void UserInitMessage::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trans.UserInitMessage.map_name)
}
inline void UserInitMessage::set_map_name(const char* value, size_t size) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trans.UserInitMessage.map_name)
}
inline std::string* UserInitMessage::_internal_mutable_map_name() {
  
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserInitMessage::release_map_name() {
  // @@protoc_insertion_point(field_release:trans.UserInitMessage.map_name)
  
  return map_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserInitMessage::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:trans.UserInitMessage.map_name)
}

// -------------------------------------------------------------------

// NewPlayerMessage

// int32 id = 1;
inline void NewPlayerMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewPlayerMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewPlayerMessage::id() const {
  // @@protoc_insertion_point(field_get:trans.NewPlayerMessage.id)
  return _internal_id();
}
inline void NewPlayerMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void NewPlayerMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:trans.NewPlayerMessage.id)
}

// string username = 2;
inline void NewPlayerMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NewPlayerMessage::username() const {
  // @@protoc_insertion_point(field_get:trans.NewPlayerMessage.username)
  return _internal_username();
}
inline void NewPlayerMessage::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:trans.NewPlayerMessage.username)
}
inline std::string* NewPlayerMessage::mutable_username() {
  // @@protoc_insertion_point(field_mutable:trans.NewPlayerMessage.username)
  return _internal_mutable_username();
}
inline const std::string& NewPlayerMessage::_internal_username() const {
  return username_.GetNoArena();
}
inline void NewPlayerMessage::_internal_set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NewPlayerMessage::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trans.NewPlayerMessage.username)
}
inline void NewPlayerMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trans.NewPlayerMessage.username)
}
inline void NewPlayerMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trans.NewPlayerMessage.username)
}
inline std::string* NewPlayerMessage::_internal_mutable_username() {
  
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NewPlayerMessage::release_username() {
  // @@protoc_insertion_point(field_release:trans.NewPlayerMessage.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:trans.NewPlayerMessage.username)
}

// float x = 3;
inline void NewPlayerMessage::clear_x() {
  x_ = 0;
}
inline float NewPlayerMessage::_internal_x() const {
  return x_;
}
inline float NewPlayerMessage::x() const {
  // @@protoc_insertion_point(field_get:trans.NewPlayerMessage.x)
  return _internal_x();
}
inline void NewPlayerMessage::_internal_set_x(float value) {
  
  x_ = value;
}
inline void NewPlayerMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:trans.NewPlayerMessage.x)
}

// float y = 4;
inline void NewPlayerMessage::clear_y() {
  y_ = 0;
}
inline float NewPlayerMessage::_internal_y() const {
  return y_;
}
inline float NewPlayerMessage::y() const {
  // @@protoc_insertion_point(field_get:trans.NewPlayerMessage.y)
  return _internal_y();
}
inline void NewPlayerMessage::_internal_set_y(float value) {
  
  y_ = value;
}
inline void NewPlayerMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:trans.NewPlayerMessage.y)
}

// string map_name = 5;
inline void NewPlayerMessage::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NewPlayerMessage::map_name() const {
  // @@protoc_insertion_point(field_get:trans.NewPlayerMessage.map_name)
  return _internal_map_name();
}
inline void NewPlayerMessage::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:trans.NewPlayerMessage.map_name)
}
inline std::string* NewPlayerMessage::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:trans.NewPlayerMessage.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& NewPlayerMessage::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void NewPlayerMessage::_internal_set_map_name(const std::string& value) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NewPlayerMessage::set_map_name(std::string&& value) {
  
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trans.NewPlayerMessage.map_name)
}
inline void NewPlayerMessage::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trans.NewPlayerMessage.map_name)
}
inline void NewPlayerMessage::set_map_name(const char* value, size_t size) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trans.NewPlayerMessage.map_name)
}
inline std::string* NewPlayerMessage::_internal_mutable_map_name() {
  
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NewPlayerMessage::release_map_name() {
  // @@protoc_insertion_point(field_release:trans.NewPlayerMessage.map_name)
  
  return map_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerMessage::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:trans.NewPlayerMessage.map_name)
}

// -------------------------------------------------------------------

// UpdatePlayerMessage_Direction

// bool up = 1;
inline void UpdatePlayerMessage_Direction::clear_up() {
  up_ = false;
}
inline bool UpdatePlayerMessage_Direction::_internal_up() const {
  return up_;
}
inline bool UpdatePlayerMessage_Direction::up() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.Direction.up)
  return _internal_up();
}
inline void UpdatePlayerMessage_Direction::_internal_set_up(bool value) {
  
  up_ = value;
}
inline void UpdatePlayerMessage_Direction::set_up(bool value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.Direction.up)
}

// bool left = 2;
inline void UpdatePlayerMessage_Direction::clear_left() {
  left_ = false;
}
inline bool UpdatePlayerMessage_Direction::_internal_left() const {
  return left_;
}
inline bool UpdatePlayerMessage_Direction::left() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.Direction.left)
  return _internal_left();
}
inline void UpdatePlayerMessage_Direction::_internal_set_left(bool value) {
  
  left_ = value;
}
inline void UpdatePlayerMessage_Direction::set_left(bool value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.Direction.left)
}

// bool right = 3;
inline void UpdatePlayerMessage_Direction::clear_right() {
  right_ = false;
}
inline bool UpdatePlayerMessage_Direction::_internal_right() const {
  return right_;
}
inline bool UpdatePlayerMessage_Direction::right() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.Direction.right)
  return _internal_right();
}
inline void UpdatePlayerMessage_Direction::_internal_set_right(bool value) {
  
  right_ = value;
}
inline void UpdatePlayerMessage_Direction::set_right(bool value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.Direction.right)
}

// bool down = 4;
inline void UpdatePlayerMessage_Direction::clear_down() {
  down_ = false;
}
inline bool UpdatePlayerMessage_Direction::_internal_down() const {
  return down_;
}
inline bool UpdatePlayerMessage_Direction::down() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.Direction.down)
  return _internal_down();
}
inline void UpdatePlayerMessage_Direction::_internal_set_down(bool value) {
  
  down_ = value;
}
inline void UpdatePlayerMessage_Direction::set_down(bool value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.Direction.down)
}

// bool fire = 5;
inline void UpdatePlayerMessage_Direction::clear_fire() {
  fire_ = false;
}
inline bool UpdatePlayerMessage_Direction::_internal_fire() const {
  return fire_;
}
inline bool UpdatePlayerMessage_Direction::fire() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.Direction.fire)
  return _internal_fire();
}
inline void UpdatePlayerMessage_Direction::_internal_set_fire(bool value) {
  
  fire_ = value;
}
inline void UpdatePlayerMessage_Direction::set_fire(bool value) {
  _internal_set_fire(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.Direction.fire)
}

// -------------------------------------------------------------------

// UpdatePlayerMessage

// int32 id = 1;
inline void UpdatePlayerMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayerMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayerMessage::id() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.id)
  return _internal_id();
}
inline void UpdatePlayerMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdatePlayerMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.id)
}

// float x = 2;
inline void UpdatePlayerMessage::clear_x() {
  x_ = 0;
}
inline float UpdatePlayerMessage::_internal_x() const {
  return x_;
}
inline float UpdatePlayerMessage::x() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.x)
  return _internal_x();
}
inline void UpdatePlayerMessage::_internal_set_x(float value) {
  
  x_ = value;
}
inline void UpdatePlayerMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.x)
}

// float y = 3;
inline void UpdatePlayerMessage::clear_y() {
  y_ = 0;
}
inline float UpdatePlayerMessage::_internal_y() const {
  return y_;
}
inline float UpdatePlayerMessage::y() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.y)
  return _internal_y();
}
inline void UpdatePlayerMessage::_internal_set_y(float value) {
  
  y_ = value;
}
inline void UpdatePlayerMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:trans.UpdatePlayerMessage.y)
}

// .trans.UpdatePlayerMessage.Direction direction = 4;
inline bool UpdatePlayerMessage::_internal_has_direction() const {
  return this != internal_default_instance() && direction_ != nullptr;
}
inline bool UpdatePlayerMessage::has_direction() const {
  return _internal_has_direction();
}
inline void UpdatePlayerMessage::clear_direction() {
  if (GetArenaNoVirtual() == nullptr && direction_ != nullptr) {
    delete direction_;
  }
  direction_ = nullptr;
}
inline const ::trans::UpdatePlayerMessage_Direction& UpdatePlayerMessage::_internal_direction() const {
  const ::trans::UpdatePlayerMessage_Direction* p = direction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::UpdatePlayerMessage_Direction*>(
      &::trans::_UpdatePlayerMessage_Direction_default_instance_);
}
inline const ::trans::UpdatePlayerMessage_Direction& UpdatePlayerMessage::direction() const {
  // @@protoc_insertion_point(field_get:trans.UpdatePlayerMessage.direction)
  return _internal_direction();
}
inline ::trans::UpdatePlayerMessage_Direction* UpdatePlayerMessage::release_direction() {
  // @@protoc_insertion_point(field_release:trans.UpdatePlayerMessage.direction)
  
  ::trans::UpdatePlayerMessage_Direction* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::trans::UpdatePlayerMessage_Direction* UpdatePlayerMessage::_internal_mutable_direction() {
  
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::UpdatePlayerMessage_Direction>(GetArenaNoVirtual());
    direction_ = p;
  }
  return direction_;
}
inline ::trans::UpdatePlayerMessage_Direction* UpdatePlayerMessage::mutable_direction() {
  // @@protoc_insertion_point(field_mutable:trans.UpdatePlayerMessage.direction)
  return _internal_mutable_direction();
}
inline void UpdatePlayerMessage::set_allocated_direction(::trans::UpdatePlayerMessage_Direction* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:trans.UpdatePlayerMessage.direction)
}

// -------------------------------------------------------------------

// NewBulletMessage

// int32 id = 1;
inline void NewBulletMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewBulletMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewBulletMessage::id() const {
  // @@protoc_insertion_point(field_get:trans.NewBulletMessage.id)
  return _internal_id();
}
inline void NewBulletMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void NewBulletMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:trans.NewBulletMessage.id)
}

// float x = 2;
inline void NewBulletMessage::clear_x() {
  x_ = 0;
}
inline float NewBulletMessage::_internal_x() const {
  return x_;
}
inline float NewBulletMessage::x() const {
  // @@protoc_insertion_point(field_get:trans.NewBulletMessage.x)
  return _internal_x();
}
inline void NewBulletMessage::_internal_set_x(float value) {
  
  x_ = value;
}
inline void NewBulletMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:trans.NewBulletMessage.x)
}

// float y = 3;
inline void NewBulletMessage::clear_y() {
  y_ = 0;
}
inline float NewBulletMessage::_internal_y() const {
  return y_;
}
inline float NewBulletMessage::y() const {
  // @@protoc_insertion_point(field_get:trans.NewBulletMessage.y)
  return _internal_y();
}
inline void NewBulletMessage::_internal_set_y(float value) {
  
  y_ = value;
}
inline void NewBulletMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:trans.NewBulletMessage.y)
}

// string map_name = 4;
inline void NewBulletMessage::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NewBulletMessage::map_name() const {
  // @@protoc_insertion_point(field_get:trans.NewBulletMessage.map_name)
  return _internal_map_name();
}
inline void NewBulletMessage::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:trans.NewBulletMessage.map_name)
}
inline std::string* NewBulletMessage::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:trans.NewBulletMessage.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& NewBulletMessage::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void NewBulletMessage::_internal_set_map_name(const std::string& value) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NewBulletMessage::set_map_name(std::string&& value) {
  
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trans.NewBulletMessage.map_name)
}
inline void NewBulletMessage::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trans.NewBulletMessage.map_name)
}
inline void NewBulletMessage::set_map_name(const char* value, size_t size) {
  
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trans.NewBulletMessage.map_name)
}
inline std::string* NewBulletMessage::_internal_mutable_map_name() {
  
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NewBulletMessage::release_map_name() {
  // @@protoc_insertion_point(field_release:trans.NewBulletMessage.map_name)
  
  return map_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NewBulletMessage::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:trans.NewBulletMessage.map_name)
}

// -------------------------------------------------------------------

// UpdateBulletMessage_Direction

// bool up = 1;
inline void UpdateBulletMessage_Direction::clear_up() {
  up_ = false;
}
inline bool UpdateBulletMessage_Direction::_internal_up() const {
  return up_;
}
inline bool UpdateBulletMessage_Direction::up() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.Direction.up)
  return _internal_up();
}
inline void UpdateBulletMessage_Direction::_internal_set_up(bool value) {
  
  up_ = value;
}
inline void UpdateBulletMessage_Direction::set_up(bool value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.Direction.up)
}

// bool left = 2;
inline void UpdateBulletMessage_Direction::clear_left() {
  left_ = false;
}
inline bool UpdateBulletMessage_Direction::_internal_left() const {
  return left_;
}
inline bool UpdateBulletMessage_Direction::left() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.Direction.left)
  return _internal_left();
}
inline void UpdateBulletMessage_Direction::_internal_set_left(bool value) {
  
  left_ = value;
}
inline void UpdateBulletMessage_Direction::set_left(bool value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.Direction.left)
}

// bool right = 3;
inline void UpdateBulletMessage_Direction::clear_right() {
  right_ = false;
}
inline bool UpdateBulletMessage_Direction::_internal_right() const {
  return right_;
}
inline bool UpdateBulletMessage_Direction::right() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.Direction.right)
  return _internal_right();
}
inline void UpdateBulletMessage_Direction::_internal_set_right(bool value) {
  
  right_ = value;
}
inline void UpdateBulletMessage_Direction::set_right(bool value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.Direction.right)
}

// bool down = 4;
inline void UpdateBulletMessage_Direction::clear_down() {
  down_ = false;
}
inline bool UpdateBulletMessage_Direction::_internal_down() const {
  return down_;
}
inline bool UpdateBulletMessage_Direction::down() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.Direction.down)
  return _internal_down();
}
inline void UpdateBulletMessage_Direction::_internal_set_down(bool value) {
  
  down_ = value;
}
inline void UpdateBulletMessage_Direction::set_down(bool value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.Direction.down)
}

// -------------------------------------------------------------------

// UpdateBulletMessage

// int32 id = 1;
inline void UpdateBulletMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateBulletMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateBulletMessage::id() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.id)
  return _internal_id();
}
inline void UpdateBulletMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdateBulletMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.id)
}

// float x = 2;
inline void UpdateBulletMessage::clear_x() {
  x_ = 0;
}
inline float UpdateBulletMessage::_internal_x() const {
  return x_;
}
inline float UpdateBulletMessage::x() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.x)
  return _internal_x();
}
inline void UpdateBulletMessage::_internal_set_x(float value) {
  
  x_ = value;
}
inline void UpdateBulletMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.x)
}

// float y = 3;
inline void UpdateBulletMessage::clear_y() {
  y_ = 0;
}
inline float UpdateBulletMessage::_internal_y() const {
  return y_;
}
inline float UpdateBulletMessage::y() const {
  // @@protoc_insertion_point(field_get:trans.UpdateBulletMessage.y)
  return _internal_y();
}
inline void UpdateBulletMessage::_internal_set_y(float value) {
  
  y_ = value;
}
inline void UpdateBulletMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:trans.UpdateBulletMessage.y)
}

// -------------------------------------------------------------------

// ServerToUserMessage

// .trans.ServerToUserMessage.MessageType type = 1;
inline void ServerToUserMessage::clear_type() {
  type_ = 0;
}
inline ::trans::ServerToUserMessage_MessageType ServerToUserMessage::_internal_type() const {
  return static_cast< ::trans::ServerToUserMessage_MessageType >(type_);
}
inline ::trans::ServerToUserMessage_MessageType ServerToUserMessage::type() const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserMessage.type)
  return _internal_type();
}
inline void ServerToUserMessage::_internal_set_type(::trans::ServerToUserMessage_MessageType value) {
  
  type_ = value;
}
inline void ServerToUserMessage::set_type(::trans::ServerToUserMessage_MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:trans.ServerToUserMessage.type)
}

// .trans.NewPlayerMessage np_msg = 2;
inline bool ServerToUserMessage::_internal_has_np_msg() const {
  return this != internal_default_instance() && np_msg_ != nullptr;
}
inline bool ServerToUserMessage::has_np_msg() const {
  return _internal_has_np_msg();
}
inline void ServerToUserMessage::clear_np_msg() {
  if (GetArenaNoVirtual() == nullptr && np_msg_ != nullptr) {
    delete np_msg_;
  }
  np_msg_ = nullptr;
}
inline const ::trans::NewPlayerMessage& ServerToUserMessage::_internal_np_msg() const {
  const ::trans::NewPlayerMessage* p = np_msg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::NewPlayerMessage*>(
      &::trans::_NewPlayerMessage_default_instance_);
}
inline const ::trans::NewPlayerMessage& ServerToUserMessage::np_msg() const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserMessage.np_msg)
  return _internal_np_msg();
}
inline ::trans::NewPlayerMessage* ServerToUserMessage::release_np_msg() {
  // @@protoc_insertion_point(field_release:trans.ServerToUserMessage.np_msg)
  
  ::trans::NewPlayerMessage* temp = np_msg_;
  np_msg_ = nullptr;
  return temp;
}
inline ::trans::NewPlayerMessage* ServerToUserMessage::_internal_mutable_np_msg() {
  
  if (np_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::NewPlayerMessage>(GetArenaNoVirtual());
    np_msg_ = p;
  }
  return np_msg_;
}
inline ::trans::NewPlayerMessage* ServerToUserMessage::mutable_np_msg() {
  // @@protoc_insertion_point(field_mutable:trans.ServerToUserMessage.np_msg)
  return _internal_mutable_np_msg();
}
inline void ServerToUserMessage::set_allocated_np_msg(::trans::NewPlayerMessage* np_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete np_msg_;
  }
  if (np_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      np_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, np_msg, submessage_arena);
    }
    
  } else {
    
  }
  np_msg_ = np_msg;
  // @@protoc_insertion_point(field_set_allocated:trans.ServerToUserMessage.np_msg)
}

// .trans.UpdatePlayerMessage upd_msg = 3;
inline bool ServerToUserMessage::_internal_has_upd_msg() const {
  return this != internal_default_instance() && upd_msg_ != nullptr;
}
inline bool ServerToUserMessage::has_upd_msg() const {
  return _internal_has_upd_msg();
}
inline void ServerToUserMessage::clear_upd_msg() {
  if (GetArenaNoVirtual() == nullptr && upd_msg_ != nullptr) {
    delete upd_msg_;
  }
  upd_msg_ = nullptr;
}
inline const ::trans::UpdatePlayerMessage& ServerToUserMessage::_internal_upd_msg() const {
  const ::trans::UpdatePlayerMessage* p = upd_msg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::UpdatePlayerMessage*>(
      &::trans::_UpdatePlayerMessage_default_instance_);
}
inline const ::trans::UpdatePlayerMessage& ServerToUserMessage::upd_msg() const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserMessage.upd_msg)
  return _internal_upd_msg();
}
inline ::trans::UpdatePlayerMessage* ServerToUserMessage::release_upd_msg() {
  // @@protoc_insertion_point(field_release:trans.ServerToUserMessage.upd_msg)
  
  ::trans::UpdatePlayerMessage* temp = upd_msg_;
  upd_msg_ = nullptr;
  return temp;
}
inline ::trans::UpdatePlayerMessage* ServerToUserMessage::_internal_mutable_upd_msg() {
  
  if (upd_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::UpdatePlayerMessage>(GetArenaNoVirtual());
    upd_msg_ = p;
  }
  return upd_msg_;
}
inline ::trans::UpdatePlayerMessage* ServerToUserMessage::mutable_upd_msg() {
  // @@protoc_insertion_point(field_mutable:trans.ServerToUserMessage.upd_msg)
  return _internal_mutable_upd_msg();
}
inline void ServerToUserMessage::set_allocated_upd_msg(::trans::UpdatePlayerMessage* upd_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete upd_msg_;
  }
  if (upd_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      upd_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upd_msg, submessage_arena);
    }
    
  } else {
    
  }
  upd_msg_ = upd_msg;
  // @@protoc_insertion_point(field_set_allocated:trans.ServerToUserMessage.upd_msg)
}

// .trans.NewBulletMessage nb_msg = 4;
inline bool ServerToUserMessage::_internal_has_nb_msg() const {
  return this != internal_default_instance() && nb_msg_ != nullptr;
}
inline bool ServerToUserMessage::has_nb_msg() const {
  return _internal_has_nb_msg();
}
inline void ServerToUserMessage::clear_nb_msg() {
  if (GetArenaNoVirtual() == nullptr && nb_msg_ != nullptr) {
    delete nb_msg_;
  }
  nb_msg_ = nullptr;
}
inline const ::trans::NewBulletMessage& ServerToUserMessage::_internal_nb_msg() const {
  const ::trans::NewBulletMessage* p = nb_msg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::NewBulletMessage*>(
      &::trans::_NewBulletMessage_default_instance_);
}
inline const ::trans::NewBulletMessage& ServerToUserMessage::nb_msg() const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserMessage.nb_msg)
  return _internal_nb_msg();
}
inline ::trans::NewBulletMessage* ServerToUserMessage::release_nb_msg() {
  // @@protoc_insertion_point(field_release:trans.ServerToUserMessage.nb_msg)
  
  ::trans::NewBulletMessage* temp = nb_msg_;
  nb_msg_ = nullptr;
  return temp;
}
inline ::trans::NewBulletMessage* ServerToUserMessage::_internal_mutable_nb_msg() {
  
  if (nb_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::NewBulletMessage>(GetArenaNoVirtual());
    nb_msg_ = p;
  }
  return nb_msg_;
}
inline ::trans::NewBulletMessage* ServerToUserMessage::mutable_nb_msg() {
  // @@protoc_insertion_point(field_mutable:trans.ServerToUserMessage.nb_msg)
  return _internal_mutable_nb_msg();
}
inline void ServerToUserMessage::set_allocated_nb_msg(::trans::NewBulletMessage* nb_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nb_msg_;
  }
  if (nb_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nb_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nb_msg, submessage_arena);
    }
    
  } else {
    
  }
  nb_msg_ = nb_msg;
  // @@protoc_insertion_point(field_set_allocated:trans.ServerToUserMessage.nb_msg)
}

// .trans.UpdateBulletMessage ub_msg = 5;
inline bool ServerToUserMessage::_internal_has_ub_msg() const {
  return this != internal_default_instance() && ub_msg_ != nullptr;
}
inline bool ServerToUserMessage::has_ub_msg() const {
  return _internal_has_ub_msg();
}
inline void ServerToUserMessage::clear_ub_msg() {
  if (GetArenaNoVirtual() == nullptr && ub_msg_ != nullptr) {
    delete ub_msg_;
  }
  ub_msg_ = nullptr;
}
inline const ::trans::UpdateBulletMessage& ServerToUserMessage::_internal_ub_msg() const {
  const ::trans::UpdateBulletMessage* p = ub_msg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::trans::UpdateBulletMessage*>(
      &::trans::_UpdateBulletMessage_default_instance_);
}
inline const ::trans::UpdateBulletMessage& ServerToUserMessage::ub_msg() const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserMessage.ub_msg)
  return _internal_ub_msg();
}
inline ::trans::UpdateBulletMessage* ServerToUserMessage::release_ub_msg() {
  // @@protoc_insertion_point(field_release:trans.ServerToUserMessage.ub_msg)
  
  ::trans::UpdateBulletMessage* temp = ub_msg_;
  ub_msg_ = nullptr;
  return temp;
}
inline ::trans::UpdateBulletMessage* ServerToUserMessage::_internal_mutable_ub_msg() {
  
  if (ub_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::trans::UpdateBulletMessage>(GetArenaNoVirtual());
    ub_msg_ = p;
  }
  return ub_msg_;
}
inline ::trans::UpdateBulletMessage* ServerToUserMessage::mutable_ub_msg() {
  // @@protoc_insertion_point(field_mutable:trans.ServerToUserMessage.ub_msg)
  return _internal_mutable_ub_msg();
}
inline void ServerToUserMessage::set_allocated_ub_msg(::trans::UpdateBulletMessage* ub_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ub_msg_;
  }
  if (ub_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ub_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ub_msg, submessage_arena);
    }
    
  } else {
    
  }
  ub_msg_ = ub_msg;
  // @@protoc_insertion_point(field_set_allocated:trans.ServerToUserMessage.ub_msg)
}

// -------------------------------------------------------------------

// ServerToUserVectorMessage

// repeated .trans.ServerToUserMessage vec_messages = 1;
inline int ServerToUserVectorMessage::_internal_vec_messages_size() const {
  return vec_messages_.size();
}
inline int ServerToUserVectorMessage::vec_messages_size() const {
  return _internal_vec_messages_size();
}
inline void ServerToUserVectorMessage::clear_vec_messages() {
  vec_messages_.Clear();
}
inline ::trans::ServerToUserMessage* ServerToUserVectorMessage::mutable_vec_messages(int index) {
  // @@protoc_insertion_point(field_mutable:trans.ServerToUserVectorMessage.vec_messages)
  return vec_messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trans::ServerToUserMessage >*
ServerToUserVectorMessage::mutable_vec_messages() {
  // @@protoc_insertion_point(field_mutable_list:trans.ServerToUserVectorMessage.vec_messages)
  return &vec_messages_;
}
inline const ::trans::ServerToUserMessage& ServerToUserVectorMessage::_internal_vec_messages(int index) const {
  return vec_messages_.Get(index);
}
inline const ::trans::ServerToUserMessage& ServerToUserVectorMessage::vec_messages(int index) const {
  // @@protoc_insertion_point(field_get:trans.ServerToUserVectorMessage.vec_messages)
  return _internal_vec_messages(index);
}
inline ::trans::ServerToUserMessage* ServerToUserVectorMessage::_internal_add_vec_messages() {
  return vec_messages_.Add();
}
inline ::trans::ServerToUserMessage* ServerToUserVectorMessage::add_vec_messages() {
  // @@protoc_insertion_point(field_add:trans.ServerToUserVectorMessage.vec_messages)
  return _internal_add_vec_messages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trans::ServerToUserMessage >&
ServerToUserVectorMessage::vec_messages() const {
  // @@protoc_insertion_point(field_list:trans.ServerToUserVectorMessage.vec_messages)
  return vec_messages_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trans

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::trans::UserToServerMessage_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trans::UserToServerMessage_MessageType>() {
  return ::trans::UserToServerMessage_MessageType_descriptor();
}
template <> struct is_proto_enum< ::trans::UserInitMessage_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trans::UserInitMessage_Action>() {
  return ::trans::UserInitMessage_Action_descriptor();
}
template <> struct is_proto_enum< ::trans::ServerToUserMessage_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trans::ServerToUserMessage_MessageType>() {
  return ::trans::ServerToUserMessage_MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transition_2eproto
